<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DnDExplorerTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.ui.explorer</a> &gt; <span class="el_source">DnDExplorerTree.java</span></div><h1>DnDExplorerTree.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2012 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    tfmorris
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 1996-2008 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.ui.explorer;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.SystemColor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.Autoscroll;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragGestureRecognizer;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.Icon;
import javax.swing.JLabel;
import javax.swing.KeyStroke;
import javax.swing.Timer;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

import org.argouml.model.Model;
import org.argouml.ui.TransferableModelElements;
import org.argouml.ui.targetmanager.TargetManager;
import org.argouml.uml.diagram.Relocatable;
import org.argouml.uml.diagram.ui.ActionSaveDiagramToClipboard;

/**
 * This class extends the default Argo JTree with Drag and drop capabilities.&lt;p&gt;
 * See &lt;a
 * href=&quot;http://java.sun.com/j2se/1.4.2/docs/guide/dragndrop/spec/dnd1.html&quot;&gt;
 * dnd1&lt;/a&gt; and &lt;a
 * href=&quot;http://java.sun.com/products/jfc/tsc/articles/dragndrop/index.html&quot;&gt;
 * dnd2&lt;/a&gt;&lt;p&gt;
 *
 * And it adds the 'copy to clipboard' capability for diagrams. See
 * &lt;a href=&quot;http://java.sun.com/j2se/1.3/docs/guide/swing/KeyBindChanges.html&quot;&gt;
 * KeyBindChanges&lt;/a&gt;&lt;p&gt;
 *
 * The ghosted images code originates from &lt;p&gt;&lt;a
 * href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip114.html&quot;&gt;
 * javatip114&lt;/a&gt;&lt;p&gt;
 *
 * Interesting may also be the following: &lt;p&gt;&lt;a
 * href=&quot;http://forum.java.sun.com/thread.jspa?threadID=296255&amp;start=30&quot;&gt;
 * thread&lt;/a&gt;
 *
 * @author  alexb
 * @since Created on 16 April 2003
 */
public class DnDExplorerTree
    extends ExplorerTree
    implements DragGestureListener,
        DragSourceListener,
        Autoscroll {
    /**
     * Logger.
     */
<span class="nc" id="L124">    private static final Logger LOG =</span>
<span class="nc" id="L125">        Logger.getLogger(DnDExplorerTree.class.getName());</span>

    private static final String DIAGRAM_TO_CLIPBOARD_ACTION =
        &quot;export Diagram as GIF&quot;;

    /**
     * Where, in the drag image, the mouse was clicked.
     */
<span class="nc" id="L133">    private Point	clickOffset = new Point();</span>

    /**
     * The path being dragged.
     */
    private TreePath		sourcePath;

    /**
     * The 'drag image'.
     */
    private BufferedImage	ghostImage;


    /**
     * The selected node.
     */
    private TreePath selectedTreePath;

    /**
     * dnd source.
     */
    private DragSource dragSource;

    /**
     * Creates a new instance of DnDArgoJTree.
     */
    public DnDExplorerTree() {

<span class="nc" id="L161">        super();</span>

<span class="nc" id="L163">        this.addTreeSelectionListener(new DnDTreeSelectionListener());</span>

<span class="nc" id="L165">        dragSource = DragSource.getDefaultDragSource();</span>

        /*
         * The drag gesture recognizer fires events
         * in response to drag gestures in a component.
         */
<span class="nc" id="L171">        DragGestureRecognizer dgr =</span>
	    dragSource
<span class="nc" id="L173">	        .createDefaultDragGestureRecognizer(</span>
		    this,
		    DnDConstants.ACTION_COPY_OR_MOVE, //specifies valid actions
		    this);

        // Eliminates right mouse clicks as valid actions
<span class="nc" id="L179">        dgr.setSourceActions(</span>
<span class="nc" id="L180">        		dgr.getSourceActions() &amp; ~InputEvent.BUTTON3_MASK);</span>

        // First argument:  Component to associate the target with
        // Second argument: DropTargetListener
<span class="nc" id="L184">        new DropTarget(this, new ArgoDropTargetListener());</span>

<span class="nc" id="L186">        KeyStroke ctrlC = KeyStroke.getKeyStroke(&quot;control C&quot;);</span>
<span class="nc" id="L187">        this.getInputMap().put(ctrlC, DIAGRAM_TO_CLIPBOARD_ACTION);</span>
<span class="nc" id="L188">        this.getActionMap().put(DIAGRAM_TO_CLIPBOARD_ACTION,</span>
                new ActionSaveDiagramToClipboard());
<span class="nc" id="L190">    }</span>

    /**
     * The drag gesture listener is notified of drag gestures by a recognizer.
     * The typical response is to initiate a drag by invoking
     * DragSource.startDrag().
     * &lt;p&gt;
     *
     * TODO: find a way to show a different image when multiple elements are
     * dragged.
     *
     * @param dragGestureEvent
     *            the DragGestureEvent describing the gesture that has just
     *            occurred
     * @see java.awt.dnd.DragGestureListener#dragGestureRecognized(java.awt.dnd.DragGestureEvent)
     */
    public void dragGestureRecognized(
            DragGestureEvent dragGestureEvent) {

        /*
         * Get the selected targets (UML ModelElements)
         * from the TargetManager.
         */
<span class="nc" id="L213">        Collection targets = TargetManager.getInstance().getModelTargets();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (targets.size() &lt; 1) {</span>
<span class="nc" id="L215">            return;</span>
        }

<span class="nc" id="L218">        LOG.log(Level.FINE, &quot;Drag: start transferring {0} targets.&quot;, targets.size());</span>

<span class="nc" id="L220">        TransferableModelElements tf =</span>
            new TransferableModelElements(targets);

<span class="nc" id="L223">        Point ptDragOrigin = dragGestureEvent.getDragOrigin();</span>
<span class="nc" id="L224">        TreePath path =</span>
<span class="nc" id="L225">            getPathForLocation(ptDragOrigin.x, ptDragOrigin.y);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (path == null) {</span>
<span class="nc" id="L227">            return;</span>
        }
<span class="nc" id="L229">        Rectangle raPath = getPathBounds(path);</span>
<span class="nc" id="L230">        clickOffset.setLocation(ptDragOrigin.x - raPath.x,</span>
                ptDragOrigin.y - raPath.y);

        /*
         * Get the cell renderer (which is a JLabel)
         * for the path being dragged.
         */
<span class="nc" id="L237">        JLabel lbl =</span>
<span class="nc" id="L238">            (JLabel) getCellRenderer().getTreeCellRendererComponent(</span>
                    this,                        // tree
<span class="nc" id="L240">                    path.getLastPathComponent(), // value</span>
                    false,	// isSelected	(dont want a colored background)
<span class="nc" id="L242">                    isExpanded(path), 		 // isExpanded</span>
<span class="nc" id="L243">                    getModel().isLeaf(path.getLastPathComponent()), // isLeaf</span>
                    0, 		// row	(not important for rendering)
                    false	// hasFocus (dont want a focus rectangle)
            );
        /* The layout manager would normally do this: */
<span class="nc" id="L248">        lbl.setSize((int) raPath.getWidth(), (int) raPath.getHeight());</span>

        // Get a buffered image of the selection for dragging a ghost image
<span class="nc" id="L251">        ghostImage =</span>
            new BufferedImage(
<span class="nc" id="L253">                (int) raPath.getWidth(), (int) raPath.getHeight(),</span>
                BufferedImage.TYPE_INT_ARGB_PRE);
<span class="nc" id="L255">        Graphics2D g2 = ghostImage.createGraphics();</span>

        /*
         * Ask the cell renderer to paint itself into the BufferedImage.
         * Make the image ghostlike.
         */
<span class="nc" id="L261">        g2.setComposite(AlphaComposite.getInstance(</span>
                AlphaComposite.SRC, 0.5f));
<span class="nc" id="L263">        lbl.paint(g2);</span>

        /*
         * Now paint a gradient UNDER the ghosted JLabel text
         * (but not under the icon if any).
         */
<span class="nc" id="L269">        Icon icon = lbl.getIcon();</span>
        int nStartOfText =
<span class="nc bnc" id="L271" title="All 2 branches missed.">            (icon == null) ? 0</span>
<span class="nc" id="L272">                : icon.getIconWidth() + lbl.getIconTextGap();</span>
        /* Make the gradient ghostlike: */
<span class="nc" id="L274">        g2.setComposite(AlphaComposite.getInstance(</span>
                AlphaComposite.DST_OVER, 0.5f));
<span class="nc" id="L276">        g2.setPaint(new GradientPaint(nStartOfText,	0,</span>
                SystemColor.controlShadow,
<span class="nc" id="L278">                getWidth(), 0, new Color(255, 255, 255, 0)));</span>
<span class="nc" id="L279">        g2.fillRect(nStartOfText, 0, getWidth(), ghostImage.getHeight());</span>

<span class="nc" id="L281">        g2.dispose();</span>

        /*
         * Remember the path being dragged (because if it is being moved,
         * we will have to delete it later).
         */
<span class="nc" id="L287">        sourcePath = path;</span>

        /*
         * We pass our drag image just in case
         * it IS supported by the platform.
         */
<span class="nc" id="L293">        dragGestureEvent.startDrag(null, ghostImage,</span>
                new Point(5, 5), tf, this);
<span class="nc" id="L295">    }</span>

    private boolean isValidDrag(TreePath destinationPath,
    		Transferable tf) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (destinationPath == null) {</span>
<span class="nc" id="L300">            LOG.log(Level.FINE, &quot;No valid Drag: no destination found.&quot;);</span>
<span class="nc" id="L301">            return false;</span>
        }
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (selectedTreePath.isDescendant(destinationPath)) {</span>
<span class="nc" id="L304">            LOG.log(Level.FINE, &quot;No valid Drag: move to descendent.&quot;);</span>
<span class="nc" id="L305">            return false;</span>
        }
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (!tf.isDataFlavorSupported(</span>
                TransferableModelElements.UML_COLLECTION_FLAVOR)) {
<span class="nc" id="L309">            LOG.log(Level.FINE, &quot;No valid Drag: flavor not supported.&quot;);</span>
<span class="nc" id="L310">            return false;</span>
        }
<span class="nc" id="L312">        Object dest =</span>
            ((DefaultMutableTreeNode) destinationPath
<span class="nc" id="L314">                .getLastPathComponent()).getUserObject();</span>

        /* TODO: support other types of drag.
         * Here you set the owner by dragging into a namespace.
         * An alternative could be to drag states into composite states...
         */

        /* If the destination is not a NameSpace, then abort: */
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (!Model.getFacade().isANamespace(dest)) {</span>
<span class="nc" id="L323">            LOG.log(Level.FINE, &quot;No valid Drag: not a namespace.&quot;);</span>
<span class="nc" id="L324">            return false;</span>
        }

        /* We are sure &quot;dest&quot; is a Namespace now. */
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (Model.getModelManagementHelper().isReadOnly(dest)) {</span>
<span class="nc" id="L329">            LOG.log(Level.FINE, &quot;No valid Drag: &quot;</span>
                    + &quot;this is not an editable UML element (profile?).&quot;);
<span class="nc" id="L331">            return false;</span>
        }

        /* If the destination is a DataType, then abort: */

        // TODO: Any Namespace can contain other elements.  Why don't we allow
        // this? - tfm
        /*
         * MVW: These are the WFRs for DataType:
         * [1] A DataType can only contain Operations,
         * which all must be queries.
         * self.allFeatures-&gt;forAll(f |
         *  f.oclIsKindOf(Operation) and f.oclAsType(Operation).isQuery)
         * [2] A DataType cannot contain any other ModelElements.
         *  self.allContents-&gt;isEmpty
         *  IMHO we should enforce these WFRs here.
         *  ... so it is still possible to copy or move query operations,
         *  hence we should allow this.
         */
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (Model.getFacade().isADataType(dest)) {</span>
<span class="nc" id="L351">            LOG.log(Level.FINE, &quot;No valid Drag: destination is a DataType.&quot;);</span>
<span class="nc" id="L352">            return false;</span>
        }

        /*
         * Let's check all dragged elements - if one of these
         * may be dropped, then the drag is valid.
         * The others will be ignored when dropping.
         */
        try {
<span class="nc" id="L361">            Collection transfers =</span>
<span class="nc" id="L362">                (Collection) tf.getTransferData(</span>
                    TransferableModelElements.UML_COLLECTION_FLAVOR);
<span class="nc bnc" id="L364" title="All 2 branches missed.">            for (Object element : transfers) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (Model.getFacade().isAUMLElement(element)) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (!Model.getModelManagementHelper().isReadOnly(element)) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                        if (Model.getFacade().isAModelElement(dest)</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                                &amp;&amp; Model.getFacade().isANamespace(element)</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                                &amp;&amp; Model.getCoreHelper().isValidNamespace(</span>
                                        element, dest)) {
<span class="nc" id="L371">                            LOG.log(Level.FINE, &quot;Valid Drag: namespace {0}&quot;, dest);</span>
<span class="nc" id="L372">                            return true;</span>
                        }
<span class="nc bnc" id="L374" title="All 2 branches missed.">                        if (Model.getFacade().isAFeature(element)</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                                &amp;&amp; Model.getFacade().isAClassifier(dest)) {</span>
<span class="nc" id="L376">                            return true;</span>
                        }
                    }
                }
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (element instanceof Relocatable) {</span>
<span class="nc" id="L381">                    Relocatable d = (Relocatable) element;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                    if (d.isRelocationAllowed(dest)) {</span>
<span class="nc" id="L383">                        LOG.log(Level.FINE, &quot;Valid Drag: diagram {0}&quot;, dest);</span>
<span class="nc" id="L384">                        return true;</span>
                    }
                }
<span class="nc" id="L387">            }</span>
<span class="nc" id="L388">        } catch (UnsupportedFlavorException e) {</span>
<span class="nc" id="L389">            LOG.log(Level.FINE, &quot;&quot;, e);</span>
<span class="nc" id="L390">        } catch (IOException e) {</span>
<span class="nc" id="L391">            LOG.log(Level.FINE, &quot;&quot;, e);</span>
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">        LOG.log(Level.FINE, &quot;No valid Drag: not a valid namespace.&quot;);</span>
<span class="nc" id="L394">        return false;</span>
    }

    /*
     * @see java.awt.dnd.DragSourceListener#dragDropEnd(java.awt.dnd.DragSourceDropEvent)
     */
    public void dragDropEnd(
    		DragSourceDropEvent dragSourceDropEvent) {
<span class="nc" id="L402">        sourcePath = null;</span>
<span class="nc" id="L403">        ghostImage = null;</span>
<span class="nc" id="L404">    }</span>

    /*
     * @see java.awt.dnd.DragSourceListener#dragEnter(java.awt.dnd.DragSourceDragEvent)
     */
    public void dragEnter(DragSourceDragEvent dragSourceDragEvent) {
        // empty implementation - not used.
<span class="nc" id="L411">    }</span>

    /*
     * @see java.awt.dnd.DragSourceListener#dragExit(java.awt.dnd.DragSourceEvent)
     */
    public void dragExit(DragSourceEvent dragSourceEvent) {
        // empty implementation - not used.
<span class="nc" id="L418">    }</span>

    /*
     * This is not the correct location to set the cursor.
     * The commented out code illustrates the calculation
     * of coordinates.
     *
     * @see java.awt.dnd.DragSourceListener#dragOver(java.awt.dnd.DragSourceDragEvent)
     */
    public void dragOver(DragSourceDragEvent dragSourceDragEvent) {
//        Transferable tf =
//            dragSourceDragEvent.getDragSourceContext().getTransferable();
//        /* This is the mouse location on the screen: */
//        Point dragLoc = dragSourceDragEvent.getLocation();
//        /* This is the JTree location on the screen: */
//        Point treeLoc = getLocationOnScreen();
//        /* Now substract to find the location within the JTree: */
//        dragLoc.translate(- treeLoc.x, - treeLoc.y);
//        TreePath destinationPath =
//        	getPathForLocation(dragLoc.x, dragLoc.y);
//         if (isValidDrag(destinationPath, tf)) {
////           dragSourceDragEvent.getDragSourceContext()
////           .setCursor(DragSource.DefaultMoveDrop);
//        } else {
////          dragSourceDragEvent.getDragSourceContext()
////          .setCursor(DragSource.DefaultCopyNoDrop);
//        }
<span class="nc" id="L445">    }</span>

    /*
     * @see java.awt.dnd.DragSourceListener#dropActionChanged(java.awt.dnd.DragSourceDragEvent)
     */
    public void dropActionChanged(
    		DragSourceDragEvent dragSourceDragEvent) {
        // empty implementation - not used.
<span class="nc" id="L453">    }</span>

    /**
     * records the selected path for later use during dnd.
     */
<span class="nc" id="L458">    class DnDTreeSelectionListener implements TreeSelectionListener {</span>
        public void valueChanged(
        		TreeSelectionEvent treeSelectionEvent) {
<span class="nc" id="L461">            selectedTreePath = treeSelectionEvent.getNewLeadSelectionPath();</span>
<span class="nc" id="L462">        }</span>
    }


//  Autoscroll Interface...
//  The following code was borrowed from the book:
// 		Java Swing
// 		By Robert Eckstein, Marc Loy &amp; Dave Wood
// 		Paperback - 1221 pages 1 Ed edition (September 1998)
// 		O'Reilly &amp; Associates; ISBN: 156592455X
 //
//  The relevant chapter of which can be found at:
// 		http://www.oreilly.com/catalog/jswing/chapter/dnd.beta.pdf

    private static final int AUTOSCROLL_MARGIN = 12;

    /*
     * Ok, we've been told to scroll because the mouse cursor is in our
     * scroll zone.
     * @see java.awt.dnd.Autoscroll#autoscroll(java.awt.Point)
     */
    public void autoscroll(Point pt) {
        // Figure out which row we're on.
<span class="nc" id="L485">        int nRow = getRowForLocation(pt.x, pt.y);</span>

        // If we are not on a row then ignore this autoscroll request
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (nRow &lt; 0) {</span>
<span class="nc" id="L489">            return;</span>
        }

<span class="nc" id="L492">        Rectangle raOuter = getBounds();</span>
        // Now decide if the row is at the top of the screen or at the
        // bottom. We do this to make the previous row (or the next
        // row) visible as appropriate. If were at the absolute top or
        // bottom, just return the first or last row respectively.

        // Is row at top of screen?
        nRow =
<span class="nc bnc" id="L500" title="All 2 branches missed.">            (pt.y + raOuter.y &lt;= AUTOSCROLL_MARGIN)</span>
                ?
                // Yes, scroll up one row
<span class="nc bnc" id="L503" title="All 2 branches missed.">                (nRow &lt;= 0 ? 0 : nRow - 1)</span>
                :
                    // No, scroll down one row
<span class="nc bnc" id="L506" title="All 2 branches missed.">                    (nRow &lt; getRowCount() - 1 ? nRow + 1 : nRow);</span>

<span class="nc" id="L508">        scrollRowToVisible(nRow);</span>
<span class="nc" id="L509">    }</span>

    /*
     * Calculate the insets for the *JTREE*, not the viewport the tree is in.
     * This makes it a bit messy.
     *
     * @see java.awt.dnd.Autoscroll#getAutoscrollInsets()
     */
    public Insets getAutoscrollInsets() {
<span class="nc" id="L518">        Rectangle raOuter = getBounds();</span>
<span class="nc" id="L519">        Rectangle raInner = getParent().getBounds();</span>
<span class="nc" id="L520">        return new Insets(</span>
                raInner.y - raOuter.y + AUTOSCROLL_MARGIN,
                raInner.x - raOuter.x + AUTOSCROLL_MARGIN,
                raOuter.height - raInner.height
                - raInner.y + raOuter.y + AUTOSCROLL_MARGIN,
                raOuter.width - raInner.width
                - raInner.x + raOuter.x + AUTOSCROLL_MARGIN);
    }

    /**
     * The DropTargetListener.
     * Handles drop target events including the drop itself.
     */
    class ArgoDropTargetListener implements DropTargetListener {

        private TreePath	 lastPath;
<span class="nc" id="L536">        private Rectangle2D cueLine = new Rectangle2D.Float();</span>
<span class="nc" id="L537">        private Rectangle2D ghostRectangle = new Rectangle2D.Float();</span>
        private Color cueLineColor;
<span class="nc" id="L539">        private Point lastMouseLocation = new Point();</span>
        private Timer hoverTimer;

        /**
         * The constructor.
         */
<span class="nc" id="L545">        public ArgoDropTargetListener() {</span>
<span class="nc" id="L546">            cueLineColor =</span>
                new Color(
<span class="nc" id="L548">                    SystemColor.controlShadow.getRed(),</span>
<span class="nc" id="L549">                    SystemColor.controlShadow.getGreen(),</span>
<span class="nc" id="L550">                    SystemColor.controlShadow.getBlue(),</span>
                    64
                );

            /* Set up a hover timer, so that a node will be
             * automatically expanded or collapsed
             * if the user lingers on it for more than a short time.
             */
<span class="nc" id="L558">            hoverTimer =</span>
<span class="nc" id="L559">                new Timer(1000, new ActionListener() {</span>
                    /*
                     * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
                     */
                    public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if (getPathForRow(0).equals/*isRootPath*/(lastPath)) {</span>
<span class="nc" id="L565">                            return;</span>
                        }
<span class="nc bnc" id="L567" title="All 2 branches missed.">                        if (isExpanded(lastPath)) {</span>
<span class="nc" id="L568">                            collapsePath(lastPath);</span>
                        } else {
<span class="nc" id="L570">                            expandPath(lastPath);</span>
                        }
<span class="nc" id="L572">                    }</span>
                });
<span class="nc" id="L574">            hoverTimer.setRepeats(false);	// Set timer to one-shot mode</span>
<span class="nc" id="L575">        }</span>

        /*
         * @see java.awt.dnd.DropTargetListener#dragEnter(java.awt.dnd.DropTargetDragEvent)
         */
        public void dragEnter(
                DropTargetDragEvent dropTargetDragEvent) {
<span class="nc" id="L582">            LOG.log(Level.FINE, &quot;dragEnter&quot;);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (!isDragAcceptable(dropTargetDragEvent)) {</span>
<span class="nc" id="L584">                dropTargetDragEvent.rejectDrag();</span>
            } else {
<span class="nc" id="L586">                dropTargetDragEvent.acceptDrag(</span>
<span class="nc" id="L587">                        dropTargetDragEvent.getDropAction());</span>
            }
<span class="nc" id="L589">        }</span>

        /*
         * @see java.awt.dnd.DropTargetListener#dragExit(java.awt.dnd.DropTargetEvent)
         */
        public void dragExit(DropTargetEvent dropTargetEvent) {
<span class="nc" id="L595">            LOG.log(Level.FINE, &quot;dragExit&quot;);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            if (!DragSource.isDragImageSupported()) {</span>
<span class="nc" id="L597">                repaint(ghostRectangle.getBounds());</span>
            }
<span class="nc" id="L599">        }</span>

        /**
         * Called when a drag operation is ongoing, while the mouse pointer
         * is still over the operable part of the drop site
         * for the &lt;code&gt;DropTarget&lt;/code&gt; registered with this listener.
         *
         * @see java.awt.dnd.DropTargetListener#dragOver(java.awt.dnd.DropTargetDragEvent)
         */
        public void dragOver(DropTargetDragEvent dropTargetDragEvent) {
<span class="nc" id="L609">            Point pt = dropTargetDragEvent.getLocation();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (pt.equals(lastMouseLocation)) {</span>
<span class="nc" id="L611">                return;</span>
            }
            /* Many many of these events .. this slows things down: */
//            LOG.log(Level.FINE, &quot;dragOver&quot;);

<span class="nc" id="L616">            lastMouseLocation = pt;</span>

<span class="nc" id="L618">            Graphics2D g2 = (Graphics2D) getGraphics();</span>

            /*
             * The next condition becomes false when dragging in
             * something from another application.
             */
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (ghostImage != null) {</span>
                /*
                 * If a drag image is not supported by the platform,
                 * then draw my own drag image.
                 */
<span class="nc bnc" id="L629" title="All 2 branches missed.">                if (!DragSource.isDragImageSupported()) {</span>
                    /* Rub out the last ghost image and cue line: */
<span class="nc" id="L631">                    paintImmediately(ghostRectangle.getBounds());</span>
                    /* And remember where we are about to draw
                     * the new ghost image:
                     */
<span class="nc" id="L635">                    ghostRectangle.setRect(pt.x - clickOffset.x,</span>
<span class="nc" id="L636">                            pt.y - clickOffset.y,</span>
<span class="nc" id="L637">                            ghostImage.getWidth(),</span>
<span class="nc" id="L638">                            ghostImage.getHeight());</span>
<span class="nc" id="L639">                    g2.drawImage(ghostImage,</span>
<span class="nc" id="L640">                            AffineTransform.getTranslateInstance(</span>
<span class="nc" id="L641">                                    ghostRectangle.getX(),</span>
<span class="nc" id="L642">                                    ghostRectangle.getY()), null);</span>
                } else {
                    // Just rub out the last cue line
<span class="nc" id="L645">                    paintImmediately(cueLine.getBounds());</span>
                }
            }

<span class="nc" id="L649">            TreePath path = getPathForLocation(pt.x, pt.y);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (!(path == lastPath)) {</span>
<span class="nc" id="L651">                lastPath = path;</span>
<span class="nc" id="L652">                hoverTimer.restart();</span>
            }

            /*
             * In any case draw (over the ghost image if necessary)
             * a cue line indicating where a drop will occur.
             */
<span class="nc" id="L659">            Rectangle raPath = getPathBounds(path);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (raPath != null) {</span>
<span class="nc" id="L661">                cueLine.setRect(0,</span>
<span class="nc" id="L662">                        raPath.y + (int) raPath.getHeight(),</span>
<span class="nc" id="L663">                        getWidth(),</span>
                        2);
            }

<span class="nc" id="L667">            g2.setColor(cueLineColor);</span>
<span class="nc" id="L668">            g2.fill(cueLine);</span>

            // And include the cue line in the area to be rubbed out next time
<span class="nc" id="L671">            ghostRectangle = ghostRectangle.createUnion(cueLine);</span>

            /* Testcase: drag something from another
             * application into ArgoUML,
             * and the explorer shows the drop icon, instead of the noDrop.
             */
            try {
<span class="nc bnc" id="L678" title="All 2 branches missed.">                if (!dropTargetDragEvent.isDataFlavorSupported(</span>
                        TransferableModelElements.UML_COLLECTION_FLAVOR)) {
<span class="nc" id="L680">                    dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L681">                    return;</span>
                }
<span class="nc" id="L683">            } catch (NullPointerException e) {</span>
<span class="nc" id="L684">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L685">                return;</span>
<span class="nc" id="L686">            }</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">            if (path == null) {</span>
<span class="nc" id="L689">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L690">                return;</span>
            }
            // to prohibit dropping onto the drag source:
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (path.equals(sourcePath)) {</span>
<span class="nc" id="L694">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L695">                return;</span>
            }
<span class="nc bnc" id="L697" title="All 2 branches missed.">            if (selectedTreePath.isDescendant(path)) {</span>
<span class="nc" id="L698">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L699">                return;</span>
            }

<span class="nc" id="L702">            Object dest =</span>
                ((DefaultMutableTreeNode) path
<span class="nc" id="L704">                    .getLastPathComponent()).getUserObject();</span>

            /* If the destination is not a NameSpace, then reject: */
<span class="nc bnc" id="L707" title="All 2 branches missed.">            if (!Model.getFacade().isANamespace(dest)) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                if (LOG.isLoggable(Level.FINE)) {</span>
                    String name;
<span class="nc bnc" id="L710" title="All 2 branches missed.">                    if (Model.getFacade().isAUMLElement(dest)) {</span>
<span class="nc" id="L711">                        name = Model.getFacade().getName(dest);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    } else if (dest == null) {</span>
<span class="nc" id="L713">                        name = &quot;&lt;null&gt;&quot;;</span>
                    } else {
<span class="nc" id="L715">                        name = dest.toString();</span>
                    }
<span class="nc" id="L717">                    LOG.log(Level.FINE, &quot;No valid Drag: &quot;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                            + (Model.getFacade().isAUMLElement(dest)</span>
<span class="nc" id="L719">                                    ? name + &quot; not a namespace.&quot;</span>
<span class="nc" id="L720">                                    :  &quot; not a UML element.&quot;));</span>
                }
<span class="nc" id="L722">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L723">                return;</span>
            }
            /* We are sure &quot;dest&quot; is a Namespace now. */

<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (Model.getModelManagementHelper().isReadOnly(dest)) {</span>
<span class="nc" id="L728">                LOG.log(Level.FINE, &quot;No valid Drag: &quot;</span>
                        + &quot;not an editable UML element (profile?).&quot;);
<span class="nc" id="L730">                return;</span>
            }

            /* If the destination is a DataType, then reject: */
<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (Model.getFacade().isADataType(dest)) {</span>
<span class="nc" id="L735">                LOG.log(Level.FINE, &quot;No valid Drag: destination is a DataType.&quot;);</span>
<span class="nc" id="L736">                dropTargetDragEvent.rejectDrag();</span>
<span class="nc" id="L737">                return;</span>
            }

<span class="nc" id="L740">            dropTargetDragEvent.acceptDrag(</span>
<span class="nc" id="L741">                    dropTargetDragEvent.getDropAction());</span>
<span class="nc" id="L742">        }</span>

        /**
         * The drop: what is done when the mousebutton is released.
         *
         * @see java.awt.dnd.DropTargetListener#drop(java.awt.dnd.DropTargetDropEvent)
         */
        public void drop(DropTargetDropEvent dropTargetDropEvent) {
<span class="nc" id="L750">            LOG.log(Level.FINE, &quot;dropping ... &quot;);</span>
            /* Prevent hover timer from doing an unwanted
             * expandPath or collapsePath:
             */
<span class="nc" id="L754">            hoverTimer.stop();</span>

            /* Clear the ghost image: */
<span class="nc" id="L757">            repaint(ghostRectangle.getBounds());</span>

<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (!isDropAcceptable(dropTargetDropEvent)) {</span>
<span class="nc" id="L760">                dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L761">                return;</span>
            }

            try {
<span class="nc" id="L765">                Transferable tr = dropTargetDropEvent.getTransferable();</span>
                //get new parent node
<span class="nc" id="L767">                Point loc = dropTargetDropEvent.getLocation();</span>
<span class="nc" id="L768">                TreePath destinationPath = getPathForLocation(loc.x, loc.y);</span>
                
<span class="nc" id="L770">                LOG.log(Level.FINE, &quot;Drop location: x={0} y= {1}&quot; , new Object[]{loc.x,loc.y});</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">                if (!isValidDrag(destinationPath, tr)) {</span>
<span class="nc" id="L773">                    dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L774">                    return;</span>
                }

                //get the model elements that are being transfered.
<span class="nc" id="L778">                Collection modelElements =</span>
<span class="nc" id="L779">                    (Collection) tr.getTransferData(</span>
                        TransferableModelElements.UML_COLLECTION_FLAVOR);
                
<span class="nc" id="L782">                LOG.log(Level.FINE, &quot;transfer data = {0}&quot;, modelElements);</span>

<span class="nc" id="L784">                Object dest =</span>
                    ((DefaultMutableTreeNode) destinationPath
<span class="nc" id="L786">                        .getLastPathComponent()).getUserObject();</span>
<span class="nc" id="L787">                Object src =</span>
<span class="nc" id="L788">                    ((DefaultMutableTreeNode) sourcePath</span>
<span class="nc" id="L789">                        .getLastPathComponent()).getUserObject();</span>

<span class="nc" id="L791">                int action = dropTargetDropEvent.getDropAction();</span>
                /* The user-DropActions are:
                 * Ctrl + Shift -&gt; ACTION_LINK
                 * Ctrl         -&gt; ACTION_COPY
                 * Shift        -&gt; ACTION_MOVE
                 * (none)       -&gt; ACTION_MOVE
                 */
<span class="nc bnc" id="L798" title="All 2 branches missed.">                boolean copyAction =</span>
                    (action == DnDConstants.ACTION_COPY);
<span class="nc bnc" id="L800" title="All 2 branches missed.">                boolean moveAction =</span>
                    (action == DnDConstants.ACTION_MOVE);

<span class="nc bnc" id="L803" title="All 4 branches missed.">                if (!(moveAction || copyAction)) {</span>
<span class="nc" id="L804">                    dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L805">                    return;</span>
                }

<span class="nc bnc" id="L808" title="All 2 branches missed.">                if (Model.getFacade().isAUMLElement(dest)) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                    if (Model.getModelManagementHelper().isReadOnly(dest)) {</span>
<span class="nc" id="L810">                        dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L811">                        return;</span>
                    }
                }
<span class="nc bnc" id="L814" title="All 2 branches missed.">                if (Model.getFacade().isAUMLElement(src)) {</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                    if (Model.getModelManagementHelper().isReadOnly(src)) {</span>
<span class="nc" id="L816">                        dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L817">                        return;</span>
                    }
                }

                // TODO: Really should be Element/ModelElement, but we don't
                // have a type which is portable for this
<span class="nc" id="L823">                Collection&lt;Object&gt; newTargets = new ArrayList&lt;Object&gt;();</span>
                try {
<span class="nc" id="L825">                    dropTargetDropEvent.acceptDrop(action);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                    for (Object me : modelElements) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                        if (Model.getFacade().isAUMLElement(me)) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                            if (Model.getModelManagementHelper().isReadOnly(me)) {</span>
<span class="nc" id="L829">                                continue;</span>
                            }
                        }
                        
<span class="nc bnc" id="L833" title="All 2 branches missed.">                        LOG.log(Level.FINE,(moveAction ? &quot;move &quot; : &quot;copy &quot;) + me);</span>
                        
<span class="nc bnc" id="L835" title="All 2 branches missed.">                        if (Model.getCoreHelper().isValidNamespace(me, dest)) {</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                            if (moveAction) {</span>
<span class="nc" id="L837">                                Model.getCoreHelper().setNamespace(me, dest);</span>
<span class="nc" id="L838">                                newTargets.add(me);</span>
                            }
<span class="nc bnc" id="L840" title="All 2 branches missed.">                            if (copyAction) {</span>
                                try {
<span class="nc" id="L842">                                    newTargets.add(Model.getCopyHelper()</span>
<span class="nc" id="L843">                                            .copy(me, dest));</span>
<span class="nc" id="L844">                                } catch (RuntimeException e) {</span>
                                    /* TODO: The copy function is not yet
                                     * completely implemented - so we will
                                     * have some exceptions here and there.*/
<span class="nc" id="L848">                                    LOG.log(Level.SEVERE, &quot;Exception&quot;, e);</span>
<span class="nc" id="L849">                                }</span>
                            }
                        }
<span class="nc bnc" id="L852" title="All 2 branches missed.">                        if (me instanceof Relocatable) {</span>
<span class="nc" id="L853">                            Relocatable d = (Relocatable) me;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                            if (d.isRelocationAllowed(dest)) {</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                                if (d.relocate(dest)) {</span>
<span class="nc" id="L856">                                    ExplorerEventAdaptor.getInstance()</span>
<span class="nc" id="L857">                                        .modelElementChanged(src);</span>
<span class="nc" id="L858">                                    ExplorerEventAdaptor.getInstance()</span>
<span class="nc" id="L859">                                        .modelElementChanged(dest);</span>
                                    /*TODO: Make the tree refresh and expand
                                     * really work in all cases!
                                     */
<span class="nc" id="L863">                                    makeVisible(destinationPath);</span>
<span class="nc" id="L864">                                    expandPath(destinationPath);</span>
<span class="nc" id="L865">                                    newTargets.add(me);</span>
                                }
                            }
                        }
<span class="nc bnc" id="L869" title="All 2 branches missed.">                        if (Model.getFacade().isAFeature(me)</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                                &amp;&amp; Model.getFacade().isAClassifier(dest)) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                            if (moveAction) {</span>
<span class="nc" id="L872">                                Model.getCoreHelper().removeFeature(</span>
<span class="nc" id="L873">                                        Model.getFacade().getOwner(me), me);</span>
<span class="nc" id="L874">                                Model.getCoreHelper().addFeature(dest, me);</span>
<span class="nc" id="L875">                                newTargets.add(me);</span>
                            }
<span class="nc bnc" id="L877" title="All 2 branches missed.">                            if (copyAction) {</span>
<span class="nc" id="L878">                                newTargets.add(</span>
<span class="nc" id="L879">                                        Model.getCopyHelper().copy(me, dest));</span>
                            }
                        }
<span class="nc" id="L882">                    }</span>
<span class="nc" id="L883">                    dropTargetDropEvent.getDropTargetContext()</span>
<span class="nc" id="L884">                        .dropComplete(true);</span>
<span class="nc" id="L885">                    TargetManager.getInstance().setTargets(newTargets);</span>
<span class="nc" id="L886">                } catch (java.lang.IllegalStateException ils) {</span>
<span class="nc" id="L887">                    LOG.log(Level.FINE, &quot;drop IllegalStateException&quot;);</span>
<span class="nc" id="L888">                    dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L889">                }</span>

<span class="nc" id="L891">                dropTargetDropEvent.getDropTargetContext()</span>
<span class="nc" id="L892">                    .dropComplete(true);</span>
<span class="nc" id="L893">            } catch (IOException io) {</span>
<span class="nc" id="L894">                LOG.log(Level.FINE, &quot;drop IOException&quot;);</span>
<span class="nc" id="L895">                dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L896">            } catch (UnsupportedFlavorException ufe) {</span>
<span class="nc" id="L897">                LOG.log(Level.FINE, &quot;drop UnsupportedFlavorException&quot;);</span>
<span class="nc" id="L898">                dropTargetDropEvent.rejectDrop();</span>
<span class="nc" id="L899">            }</span>
<span class="nc" id="L900">        }</span>

        /*
         * @see java.awt.dnd.DropTargetListener#dropActionChanged(java.awt.dnd.DropTargetDragEvent)
         */
        public void dropActionChanged(
                DropTargetDragEvent dropTargetDragEvent) {
<span class="nc bnc" id="L907" title="All 2 branches missed.">            if (!isDragAcceptable(dropTargetDragEvent)) {</span>
<span class="nc" id="L908">                dropTargetDragEvent.rejectDrag();</span>
            } else {
<span class="nc" id="L910">                dropTargetDragEvent.acceptDrag(</span>
<span class="nc" id="L911">                        dropTargetDragEvent.getDropAction());</span>
            }
<span class="nc" id="L913">        }</span>

        /**
         * @param dropTargetEvent the droptargetevent
         * @return true if the drag is acceptable
         */
        public boolean isDragAcceptable(
                DropTargetDragEvent dropTargetEvent) {
            // Only accept COPY or MOVE gestures (ie LINK is not supported)
<span class="nc bnc" id="L922" title="All 2 branches missed.">            if ((dropTargetEvent.getDropAction()</span>
                    &amp; DnDConstants.ACTION_COPY_OR_MOVE) == 0) {
<span class="nc" id="L924">                return false;</span>
            }

            // Do this if you want to prohibit dropping onto the drag source...
<span class="nc" id="L928">            Point pt = dropTargetEvent.getLocation();</span>
<span class="nc" id="L929">            TreePath path = getPathForLocation(pt.x, pt.y);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (path == null) {</span>
<span class="nc" id="L931">                return false;</span>
            }
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (path.equals(sourcePath)) {</span>
<span class="nc" id="L934">                return false;</span>
            }
<span class="nc" id="L936">            return true;</span>
        }

        /**
         * @param dropTargetDropEvent the droptargetdropevent
         * @return true if the drop is acceptable
         */
        public boolean isDropAcceptable(
                DropTargetDropEvent dropTargetDropEvent) {
            // Only accept COPY or MOVE gestures (ie LINK is not supported)
<span class="nc bnc" id="L946" title="All 2 branches missed.">            if ((dropTargetDropEvent.getDropAction()</span>
                    &amp; DnDConstants.ACTION_COPY_OR_MOVE) == 0) {
<span class="nc" id="L948">                return false;</span>
            }

            // Do this if you want to prohibit dropping onto the drag source...
<span class="nc" id="L952">            Point pt = dropTargetDropEvent.getLocation();</span>
<span class="nc" id="L953">            TreePath path = getPathForLocation(pt.x, pt.y);</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (path == null) {</span>
<span class="nc" id="L955">                return false;</span>
            }
<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (path.equals(sourcePath)) {</span>
<span class="nc" id="L958">                return false;</span>
            }
<span class="nc" id="L960">            return true;</span>
        }

    } /* end class */


    /**
     * The UID.
     */
    private static final long serialVersionUID = 6207230394860016617L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>